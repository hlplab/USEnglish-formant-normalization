# ----------------------------------------------------------------------------
# VOWEL SYNTHESIZER NATIVE; RANDOM SAMPLING OF HEIGHT BACKNESS SPACE OUTSIDE OF SCRIPT
# General script to generate all vowels from a native production of /had/ (from this, derive condition-specific scripts).
# Last update: 2021-05-06
# Changes made:
#	Modified the synthesizer script so that it reads in a grid instead of doing the random sampling in height/backness space from inside the script.
#	Removed token number from file name, when saving.
#	PLEASE NOTE: the script now uses predicted f3 value instead of vowel-specific generalized means across talkers.
#	PLEASE NOTE: the vowel label is commented out (for norming study purposes).
# ----------------------------------------------------------------------------
# Remaining questions: 
#	Should resampling be avoided?
# ----------------------------------------------------------------------------
#
# DESCRIPTION:
# The script automates creation of /hVd/ words from distributions of a given vowel.
# The script creates a neutral hV-section, a formant grid that filters the hV-section to create the intended vowel, then concatenates that segment to the final /d/ to create a /hVd/ word.
# The f0 value, used to generate current f1 and f2 values from the height/backness space, is expected to be the same for all vowels generated; taken from the original talker's geometric mean f0.
# f1-f2 values are generated by random sampling from a multi-variate normal distribution outside of the script, and generated by reading in a csv file and storing it as a table.
# f3 values are taken from generalized means of production data.
# f1-f3 values at final time point (/d/ closure) are automatically extracted from original /had/ production.
# f4-f8 values are automatically extracted from original /had/ production and kept constant across time points.
# The five time points are automatically extracted from original /had/ production.
# Bandwidth points are given and kept constant across words. They are assigned as numeric variables in the initial form and can be changed by the user.
# The resulting sound file is stored and GUI is cleaned up before end of script...?
# The following files are needed in order for the script to run:
#	- one soundfile (.wav) consisting of a /had/ production.
#	- one textGrid (.TextGrid), with three tiers (phone, time, word). Time tier should have five intervals, one each for the five time points (following Wade et al., 2007):
#		- time point 1 = word onset
#		- time point 2 = beginning of transition to vowel
#		- time point 3 = beginning of vowel
#		- time point 4 = beginning of transition to /d/
#		- time point 5 = /d/ closure
# 	- one csv-file with f1-f3 means, f1-f2 variances and covariances for all vowels that are to be generated.
#
#
#
# ----------------------------------------------------------------------------
# LET THE USER DEFINED THE NUMBER OF VOWEL TOKENS TO BE SYNTHESIZED PER VOWEL TYPE, 
# AND THE BASIC PROPERTIES OF OF THE FORMANT GRID
# ----------------------------------------------------------------------------
########## TO-DO: CONSIDER HAVING THE NEUTRAL FRAME ALREADY CREATED (I.E., THAT'S A SEPARATE SCRIPT) 
##########        OR TO HAVE THAT AS AN OPTION
beginPause: "Vowel Synthesizer"
	comment: "Define experimental condition"
	text: "Condition", "naturalvariability_native"
endPause: "Continue", 1
writeInfoLine: "Creating synthesized speech for condition 'condition$'"

beginPause: "Vowel Synthesizer - Formant bandwidths"
	comment: "Assign bandwidth values"
	positive: "band1_2", 500
	positive: "band3_5_f5f8", 400
	positive: "band3_5_f1", 50
	positive: "band3_5_f2", 100
	positive: "band3_5_f3", 200
	positive: "band3_5_f4", 300
endPause: "Continue", 1


# ----------------------------------------------------------------------------
# READ IN TARGET F1-F2 MEAN, VARIANCE, AND COVARIANCE FOR SYNTHESIZED SPEECH
# ----------------------------------------------------------------------------
pauseScript: "Please choose the .csv file specifying the properties of the synthesized speech."
filename_vowels$ = chooseReadFile$: "Open the .csv file specifying the properties of the synthesized speech"
appendInfoLine: filename_vowels$

if filename_vowels$ <> ""
    Read Table from comma-separated file... 'filename_vowels$'
endif
Rename: "vowels"
num_tokens = Get number of rows

# ----------------------------------------------------------------------------
# READ IN ORIGINAL FILE TO SYNTHESIZE *FROM*
# ----------------------------------------------------------------------------
pauseScript: "Please choose the recording of /had/ to synthesize from."
filename_sound_had$ = chooseReadFile$: "Open recording of /had/ to synthesize from"
if filename_sound_had$ <> ""
    Read from file: filename_sound_had$
endif
Rename: "had"

pauseScript: "Please choose the textgrid with segmentation  for /had/."
filename_textgrid_had$ = chooseReadFile$: "Open textgrid with segmentation for /had/"
if filename_textgrid_had$ <> ""
    Read from file: filename_textgrid_had$
endif
Rename: "had"

# ----------------------------------------------------------------------------
# READ IN WHERE SYNTHESIZED SPEECH SHOULD BE STORED
# ----------------------------------------------------------------------------
pauseScript: "Please choose the directory in which the synthesized sounds should be stored."
dir_output$ = chooseDirectory$: "Choose the directory for storing the synthesized .wav's"

# ----------------------------------------------------------------------------
# PREPARE FRAME (ONSET, VOWEL, OFFSET COMPONENTS)
# ----------------------------------------------------------------------------
# Assign time points
select TextGrid had
start_segment1 = Get starting point: 2, 1
start_segment2 = Get end point: 2, 1
start_segment3 = Get end point: 2, 2
start_segment4 = Get end point: 2, 3
start_segment5 = Get end point: 2, 4
writeFileLine: "'dir_output$'/timepoints.txt", "time_point1:'start_segment1', time_point2:'start_segment2', time_point3:'start_segment3', time_point4:'start_segment4', time_point5:'start_segment5'"

# Assign formant values
select Sound had
To Formant (burg)... 0 8 8800 0.025 50
select Formant had
f1_segment5 = Get value at time... 1 start_segment5 Hertz Linear
f2_segment5 = Get value at time... 2 start_segment5 Hertz Linear
f3_segment5 = Get value at time... 3 start_segment5 Hertz Linear
f4 = Get mean... 4 start_segment3 start_segment5 Hertz
f5 = Get mean... 5 start_segment3 start_segment5 Hertz
f6 = Get mean... 6 start_segment3 start_segment5 Hertz
f7 = Get mean... 7 start_segment3 start_segment5 Hertz
f8 = Get mean... 8 start_segment3 start_segment5 Hertz
writeFileLine: "'dir_output$'/formants.txt", "f1_segment5:'f1_segment5', f2_segment5:'f2_segment5', f3_segment5:'f3_segment5', f4:'f4', f5:'f5', f6:'f6', f7:'f7', f8:'f8'"

# Assign time points as numeric string
segments# = { start_segment1, start_segment2, start_segment3, start_segment4, start_segment5 }
formants# = { 0, 0, 0, f4, f5, f6, f7, f8 }
formants123_segment5# = { f1_segment5, f2_segment5, f3_segment5 }

# Segment /had/ into /h/ /vowel/ /d/
select TextGrid had
start_word = Get starting point: 1, 1
start_vowel = Get starting point: 1, 2
end_vowel = Get end point: 1, 2
end_word = Get end point: 1, 3
select Sound had
h = Extract part: start_word, start_vowel, "rectangular", 1, "no"
Rename: "h"
select Sound had
vowel = Extract part: start_vowel, end_vowel, "rectangular", 1, "no"
Rename: "vowel"
select Sound had
d = Extract part: end_vowel, end_word, "rectangular", 1, "no"
Rename: "d"
select Sound h
Resample: 44100, 50
Rename: "h"
select Sound vowel
Resample: 44100, 50
Rename: "vowel"
select Sound d
Resample: 44100, 50
Rename: "d"

# Filter the /h/ sound inversely with its LPC
select Sound h
Resample: 16000, 50
Rename: "h"
To LPC (autocorrelation): 16, 0.00125, 0.005, 50
plusObject: "Sound h"
Filter (inverse)
Resample: 44100, 50
Rename: "h"

# Create a waveform from pitch and intensity tier objects derived from the vowel
# Create a pitch tier object from original vowel
select Sound vowel
To Pitch: 0, 75, 600
Down to PitchTier

# Create a sound from pitch tier object
To PointProcess
To Sound (phonation): 44100, 1, 0.05, 0.7, 0.03, 3.0, 4.0
Rename: "vowel_new"

# Create an intensity tier object from original vowel
select Sound vowel
To Intensity: 100, 0.0, "yes"
Down to IntensityTier

# Multiply the phonation sound with the intensity tier to create the complex waveform
plusObject: "Sound vowel_new"
Multiply: "yes"
selectObject: "Sound vowel_new_int"
Resample: 44100, 50

# Create a neutral /hV/ section, concatenate to the fricative
selectObject: "Sound h", "Sound vowel_new_int_44100"
Concatenate

# Create a formant tier object to filter the /hV/ section
Create FormantGrid: "vowel", 0, start_segment5, 8, 550, 1100, 60, 50
for i from 1 to 8
	Remove formant points between: i, 0, start_segment5
	Remove bandwidth points between: i, 0, start_segment5
endfor

# Add formant points
for i from 4 to 8
	for j from 1 to size (segments#)
		Add formant point: i, segments# [j], formants# [i]
	endfor
endfor
for i from 1 to 3
	Add formant point: i, start_segment5, formants123_segment5# [i]
endfor

# Add bandwidth points
for i from 1 to 8
	Add bandwidth point: i, start_segment1, band1_2
	Add bandwidth point: i, start_segment2, band1_2

	if i = 1
		for j from 3 to size (segments#)
			Add bandwidth point: i, segments# [j], band3_5_f1
		endfor
	elsif i = 2
		for j from 3 to size (segments#)
			Add bandwidth point: i, segments# [j], band3_5_f2
		endfor
	elsif i = 3
		for j from 3 to size (segments#)
			Add bandwidth point: i, segments# [j], band3_5_f3
		endfor
	elsif i = 4
		for j from 3 to size (segments#)
			Add bandwidth point: i, segments# [j], band3_5_f4
		endfor
	else
		for j from 3 to size (segments#)
			Add bandwidth point: i, segments# [j], band3_5_f5f8
		endfor
	endif
endfor


# ----------------------------------------------------------------------------
# OUTER LOOOP: GO THROUGH ALL VOWELS
# ----------------------------------------------------------------------------
for i from 1 to num_tokens
	sr = 168 * (object [ "Table vowels", i, "synthtalker_F0" ] / 168) ^ (1/3)
	f3_current = object [ "Table vowels", i, "F3" ]
	#vowel_label$ = object$ [ "Table vowels", i, "Vowel" ]
	height_current = object [ "Table vowels", i, "height" ]
	backness_current = object [ "Table vowels", i, "backness" ]
	f1_current = sr * exp(height_current)
	f2_current = f1_current * exp(backness_current)
	writeInfoLine: sr
	#createDirectory ("'dir_output$'/'vowel_label$'")
	createDirectory ("'dir_output$'")

	select FormantGrid vowel
	Copy... current_token
	select FormantGrid current_token
	for k from 1 to 4
		Add formant point: 1, segments# [k], f1_current
		Add formant point: 2, segments# [k], f2_current
		Add formant point: 3, segments# [k], f3_current
	endfor
	# Filter the /hV/ segment with the formant grid filter
	selectObject: "Sound chain", "FormantGrid current_token"
	Filter

	# Concatenate the /hV/ segment to the /d/ segment (for this we need to copy the d down here).
	selectObject: "Sound d"
	Copy... 
	selectObject: "Sound d", "Sound chain_filt"
	Concatenate with overlap: 0.01
	f1_current = round(f1_current)
	f2_current = round(f2_current)
	#Save as WAV file: "'dir_output$'/'vowel_label$'/'vowel_label$'_'condition$'_'height_current'_'backness_current'.wav"
	Save as WAV file: "'dir_output$'/'condition$'_'height_current'_'backness_current'.wav"

	# LOOP CLEAN-UP
	selectObject: "Sound d"
	Remove
	selectObject: "Sound chain"
	Remove
	selectObject: "Sound chain_filt"
	Remove
	select FormantGrid current_token
	Remove
endfor

# Save filenames as text-file
strings = Create Strings as file list: "list", dir_output$ + "/*.wav"
Save as raw text file: "'dir_output$'/list.txt"

# ----------------------------------------------------------------------------
# CLEAN-UP
# ----------------------------------------------------------------------------
select all
Remove
printline Done!